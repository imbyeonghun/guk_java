변수

	- 변수를 선언할 수 있다.
	- 변수 선언 방법
		- 자료형 변수명 = 초기값;
	- 자료형 종류
	   - 값을 저장
	   - 정수 
	   	- byte short int long
	   - 실수
	   	- float double
	   - 문자
	   	- char
	   - 논리
	   	- boolean
	- 변수명 작성 규칙
	 	- 숫자가 첫 글자로 올 수 없다
	 	- 중복 선언이 불가능하다
	 	- 대소문자를 구별한다
	 	- 특수문자는 _와 $만 가능하다 공백도 불가능
	 	- 예약어(키워드)를 사용할 수 없다
 	
	- 변수명 작성 관례
	 	- 카멜 표기법
	 		- 변수명은 소문자로 작성
	 		- 여러 영단어로 된 경우 두번째 단어부터 첫 글자만 대문자 ex) helloWorld
	 	- 변수명은 의미있게 작성
	 	- 상수는 대문자로 작성 여러 단어인 경우 _구분
	 	
	- 자료형 변환
		- 변수나 값의 자료형을 일시적으로 변환하는 것
		- 자동 형변환(묵시적)
			- 형변환을 직접하지 않아도 자동으로 변환
			- 작은 크기의 자료형을 큰 크기의 자료형에 저장하거나 연산하는 경우
				- ex) long num = 1;
	 			- 1이라는 int형을 long로 변환하여 저장
	 		- 정수를 실수로 변환하는 경우
	 			- ex) double num = 1;
	 			- 1이라는 int정수형을 double실수형으로 변환하여 저장
		- 강제 형변환
	 		- 반드시 형변환 표시를 해줘야 함
	 			-(바꾸려는 자료형)초기값;
	 		- 큰 크기의 자료형을 작은 크기의 자료형에 저장하거나 연산하는 경우
	 			- int num = (int)1L;
	 			- 1L이라는 long형을 int로 변환하여 저장할 때
	 			- (int)를 반드시 붙여야함
	 		- 실수를 정수로 변환
	 			- int num =(int)3.14;
	 			- 3.14라는 double실수형을 int정수형으로 변환하여 저장할 때
	 			- (int)를 반드시 붙여야함
	 		- 필요에 의해 형변환
	 			- 나누기 할 때 정수/정수는 결과가 정수가 되어서 
	 			- 소수점이 사라지는 현상을 막기위해 형변환을 함
	 			- 1/2 = 0이 되기 때문에 1/(double)2를 해서 0.5가 나오도록 할 때 사용
	 			
연산자

	- 연산자 종류를 알고 결과를 예측할 수 있다.
 	- 대입 연산자 
 		- =
 		- 오른쪽 값을 왼쪽에 저장
 			- 왼쪽에는 변수만 올 수 있다.
 		- 비교 연산자 ==와 구분
 		
 	- 산술 연산자
 		- + - * / %
 		- 정수 산술 연산자 정수 => 정수
 			- 1 / 2 = 0
 		- 나누기 할 때 조심
 		- % : 나머지 연산자
 	
 	- 논리 연산자
		- 결과가 참 또는 거짓 		
 		
 		- && : ~하고, ~이고
 		- 둘 다 참이면 참,나머지는 거짓
 			
 		- || : ~이거나
 		- 둘 다 거짓이면 거짓,나머지는 참
 			
 		- ! : 반대  
	
	- 비교 연산자
		- < > <= >= == !=
		- 결과가 참 또는 거짓
		- == 와 = 을 구분
	
	- 증감 연산자
		- ++ --
		- 최종적으로 1증가 또는 1 감소
		- 전위형
			- 변수 앞에 위치
			- 증가/감소하고 동작
		- 후위형
			- 변수 뒤에 위치
			- 동작하고 증가/감소
	
	- 조건 선택 연산자
		- 조건식 ? 참 : 거짓
		- 조건이 참일 때 참을 가져오고, 거짓일 때 거짓을 가져옴
		- 조건문으로 대체가 가능
		- 이 연산자를 이용하면 코드가 간결해지는 경우가 있어서 알아두면 편함
		
	- 비트 연산자	[아두이노,LED제외하면 몰라도 크게 지장 없음]
		- 비트를 이용한 연산자
		- & | ~ ^
		- >> << >>> 
	
조건문

	- 조건문을 이용하여 다양한 상황을 처리할 수 있다.
	- ~이면 ...한다
		- ~ : 조건식
		- ... : 실행문
	- if문
		- 모든 조건문은 if문으로 표현 가능
		- 문법
			- if(조건식1){
				실행문1;
			  }else if(조건식2){
				실행문2;
			  }else{
			  	실행문3;
			  }
		- else if와 else는 없을 수도 있다
		- else if는 여러개 올 수 있다
		- if는 무조건 있어야 함
		- if는 ~하면, else는 else위의 모든 조건식이 거짓이면으로 해석
	- switch문
		- 일부 조건문을 이용할 때 사용
		- 변수의 값이 특정 값들을 가지는지 확인할 때 사용
		- 문법
			- switch(변수){
			  case 값1:
			  	실행문1;
			  	break;
			  case 값2:
			  	실행문3;
			  	break;
			  default:
			  	실행문3;
			  }
		- break는 switch문을 빠져나가는 역할
		- break는 상황에 따라 생략가능
		
반복문

	- 규칙적인 작업을 할 때 반복문을 이용할 수 있다.
	- for문
		- 문법
			- for(초기화; 조건식; 증감식){
				실행문;
			  }
			- 초기화 
				- 조건식,증감식,실행문에서 사용할 변수들을 초기화 할 수 있다
				- ,를 이용한 여러 변수를 초기화 할 수 있다
				- 변수 선언도 가능하다
				- 변수를 선언하고 다른 변수를 초기화 할 수 없다
				- 생략 가능
			- 조건식
				- 반복문을 실행할지 말지를 결정하는 곳
				- 처음 거짓이 되는 순간 반복문을 종료
				- 생략 가능
				- 생략하면 true가 됨
			- 증감식 
				- 주로 조건식에서 사용하는 변수를 증가/감소해서 반복 횟수를 조절할 때 사용
				- 생략 가능
			- 증감식,조건식,초기화를 이용하여 반복 횟수를 결정
			
	- while문
		- 문법
			- while(조건식){
			  	실행문;
			  }
			  
			- 조건식
				- 생략 불가능
				- 역할은 for문의 조건식과 같음
	- do while문
		- 문법
			- do{
				실행문;			  
			  }while(조건식);
			
			- 실행문이 무조건 1번은 실행
			- 조건식
				- 생략 불가능
				- 역할은 for문의 조건식과 같음
	- 향상된 for문
		- 문법
			- for(자료형 변수명 : 컬렉션이나 배열){
				실행문;
			  }
			- 컬렉션이나 배열에 있는 값들을 하나씩 꺼내서 확인할 때 사용

배열

	- 같은 타입의 값들을 관리할 때 배열을 이용할 수 있다
	- 컬렉션을 이용하면 배열보다 더 편하게 사용할 수 있다
	- (같은 의미)같은 자료형의 데이터를 여러개 관리할 때 배열 사용
	- 배열 생성
		- 자료형 배열명[] = new 자료형[크기];
		- 자료형[] 배열명 = new 자료형[크기];
	- 배열 초기화
		- 자료형 배열명[] = new 자료형[]{값1,값2...};
		- 자료형 배열명[] = {값1,값2...};
		- 배열명 = new 자료형[]{값1,값2...};	=> 가능
		- 배열명 = {값1,값2...};				=> 불가능
	- 배열은 0번지부터 시작
	- 배열의 크기 
		- 배열명.length를 통해 배열의 크기를 알 수 있다
	- 배열의 사용
		- 배열명[번지]를 이용하여 변수처럼 사용할 수 있다
	
클래스 

	- 현실의 정보를 클래스로 선언할 수 있다
	- 클래스를 이용하여 프로그램을 작성할 수 있다
	- 추상화
		- 현실의 정보를 클래스로 만드는 것
	- 클래스
		- 현실의 정보를 코드로 구현한 것
	- 클래스를 왜 쓸까?
		- 하나의 정보를 나타내는 여러 변수들을 따로 관리하면 불편하기 때문에
		- 묶어서 하나의 클래스로 만들어서 사용
	- 구성
		- 멤버변수
			- 클래스를 구성하는 정보
			- 일반적으로 접근제어자를 private를 설정 후 getter/setter를 추가
			- A 는 B를 가지고 있다로 표현 가능한 경우,B는 A클래스의 멤버변수가 된다(has a 관계)
		- 메서드
			- 클래스에서 제공하는 기능
			- 문법
				[] : 생략 가능
				- [접근제어자] [final] [static] 리턴타입 메서드명(매개변수들){
					구현;
				  }
				- 매개변수 
					- 메서드를 실행하기 위해 반드시 필요한 정보
					- 없을 수도 있음
				- 리턴타입
					- 기능 실행 후 알려줘야하는 값들의 자료형
		- 생성자
			- 객체를 생성한 후 생성자를 호출
			- 멤버변수들을 초기화
			- 문법
				- 접근제어자 클래스명(매개변수들){
					초기화;
				  }
				- 접근제어자는 일반적으로 public
				- 매개변수가 없으면 기본 생성자
				- 생성자 오버로딩을 이용하여 다양한 생성자를 만들 수 있다
				
	- 객체 생성 및 사용
		- 클래스명 객체명 = new 클래스명();
		- 객체명.멤버변수1 = 값;
		- 객체명.메서드();
	
	- 접근제어자
		- private
			- 본인 클래스만 사용가능
		- default
			- 본인 클래스 + 같은 패키지 클래스만 사용가능
			- default 키워드를 사용할는 것이 아니라 생략해야 함
		- protected
			- 본인 클래스 + 같은 패키지 + 자식 클래스만 사용가능
		- public
			- 모두 사용 가능
			
	- this
		- 본인 스스로를 가르키는 예약어
		- 주로 생성자나 메서드에서 매개변수명과 멤버변수명이 같은 경우 this를 반드시 사용 
	
	- this()
		- 본인 생성자 중 다른 생성자를 호출
	
	- static 
		- 같은 클래스의 모든 객체들이 공유하는 멤버변수나 메서드에 붙임
		- static이 붙은 멤버변수/메서드는 클래스가 메모리에 올라가면 생성
		- 호출은 클래스명을 통해 호출
			- 클래스명.멤버변수;
			- 클래스명.메서드();
		- 멤버변수 초기화 순서
			- 기본값
			- 명시적 초기화
			- 초기화블럭
			- 생성자
				- class A{
					int num1;		=> 기본값으로 초기화
					int num2 = 1;	=> 명시적 초기화
					int num3;
					{
						num3 = 2;	=> 초기화 블럭
					}
					int num4;
					public A(){
						num4 =3;	=> 생성자
					}
				  }
	
상속
	
	- 클래스를 상속받아 자식 클래스를 생성하여 활용할 수 있다.
	- 클래스 상속은 단일 상속
	- 클래스 상속
		- 부모 클래스의 멤버변수,메서드를 물려받는 것
	- extends 키워드 이용
	- 메서드 오버라이딩
		- 부모클래스에게 물려받은 메서드를 재정의하는 것
		- 리턴타입, 매개변수, 매서드명이 모두 동일
		- 접근제어자는 범위가 넓어지는 건 가능, 좁아지는 건 불가능
	- 클래스 형변환
		- 상속 관계인 두 클래스에서 형변환을 할 수 있다
		- 업 캐스팅
			- 자식 클래스의 객체를 부모 클래스의 객체에 저장
			- 항상 가능
		- 다운 캐스팅 
			- 부모 클래스의 객체를 자식 클래스의 객체에 저장해서 활용
			- 조건부로 가능
			- 업 캐스팅된 객체를 다시 다운 캐스팅하는 경우만 가능
	- instanceof
		- 형변환이 가능한지 알려주는 연산자
	- 다형성
		- 클래스 형변환을 통해서 한 객체에 여러 종류의 객체가 오는 것
			
추상 클래스

	- 추상 클래스를 이해할 수 있다.
	- 구체적이지 않은 클래스 = 구현이 다 안된 클래스
	- 'abstract' 키워드를 이용
	- 추상 클래스는 반드시 추상 메서드를 가진다 (X)
	- 추상 메서드
		- 구현이 되지 않은 메서드
		- 선언부만 있는 메서드
	- 추상 클래스를 이용하여 객체를 만들 수 있다 (X)
		- 상속을 통해 오버라이딩해서 자식 클래스를 이용하여 객체를 생성
	- final
		- 변수
			- 상수
		- 메서드
			- 오버라이딩이 불가능
		- 클래스
			- 부모 클래스가 될 수 없음
			- String

인터페이스

	- 추상 메서드(디폴트 메서드)와 클래스 상수로만 이루어진 것
	- 클래스가 어떤 기능을 제공하는지 알려주기 위해 사용
	- 인터페이스 상속은 다중 상속
	- 구현 클래스
		- 인터페이스의 객체를 만드려면 구현 클래스가 있어야함
		- 'implements' 키워드를 이용
		- 구현 클래스는 인터페이스의 추상 메서드들을 반드시 오버라이딩 해야 함

기본 클래스

	- Object 클래스
		- 최상위 조상 클래스
		- 모든 클래스는 Object클래스가 제공하는 메서드를 사용할 수 있다
		- 오버라이딩을 통해 재정의 할 수 있다
		- toString(), equals()를 주로 오버라이딩 함
	- String 클래스
		- 문자열 클래스
		- 문자열을 쉽게 사용할 수 있는 메서드를 제공
		- 메서드
			- equals() 	  : 두 문자열이 같은 지를 비교
			- substring() : 부분 문자열 생성
			- compareTo() : 문자열을 비교하여 사전순으로 앞이면 음수, 같으면 0, 뒤면 양수를 반환
							주로 문자열을 이용하여 정렬할 때 사용
			- split()     : 문자열을 토큰을 기준으로 추출하여 배열로 반환
	- Pattern 클래스
		- 정규표현식을 확인할 때 사용하는 클래스
	- Wapper 클래스
		- 기본 자료형을 클래스로 만든 것
		- 목적은 제네릭클래스에서 사용하기 위해
		- 클래스.parse클래스(문자열)을 통해 문자열을 각 클래스 타입으로 바꿔줌
			-Integer.parseInt("123")은 문자열 123을 정수 123으로 변환
	- Date 클래스
		- 날짜를 관리하는 클래스
		- 'SimpleDateFormat'클래스를 이용하여 날짜를 문자열로, 문자열을 날짜로 변환해서 사용

예외 처리

	- 프로그램에서 문제가 발생하여 프로그램이 중단되는 경우를 예외처리를 통해 해결할 수 있다
	- 직접처리
		-try catch를 이용
		- try{
			에러가 발생 할 수 있는 코드;
		  }catch(예외클래스 e){
		  	예외처리;
		  }finally{
		  	// 무조건 실행되는 코드;
		  }
		
	- 예외 던지기
		- throw와 throws를 이용
		- 'RuntimeException'클래스이거나 자식 클래스이면 throws를 생략할 수 있다
			- 리턴타입 메서드명(매개변수) throws{
				if(조건){
					throw new 예외클래스();
				}
			  }
	
제네릭

	- 라이브러리에서 제공하는 제네릭 클래스와 인터페이스를 사용할 수 있다
	- 멤버변수 또는 메서드의 타입이 정해지지 않은 클래스/인터페이스
	- 객체를 생성할 때 타입이 정해짐
	- 타입으로는 클래스만 올 수 있음 => 기본자료형은 올 수 없음 => Wrapper클래스를 이용
	- 제네릭 클래스 객체 생성
		- 클래스명<타입> 객체명 = new 클래스명<타입>();

컬렉션 프레임워크

	- 컬렉션과 맵에서 제공하는 메서드를 사용할 수 있다
	- 컬렉션 프레임워크는 컬렉션 + 맵
	- Collection 인터페이스
		- 한 종류의 값을 관리
		- List 인터페이스
			- ArrayList LinkedList 
			- 순서 보장, 중복 가능
			- 번지를 통해 접근이 가능
		- Set 인터페이스
			- HashSet TreeSet
			- 순서 보장 X, 중복 불가능
			- 번지를 통해 접근이 불가능
	- Map 인터페이스
		- 두 종류의 값을 관리
			- Key,Value
			- Key 중복 불가능
			- Value 중복 가능

람다식

	- 람다식을 활용할 수 있다
	- 함수형 인터페이스의 구현 클래스의 객체가 필요한 경우 사용
	- 함수형 인터페이스
		- 인터페이스의 추상 메서드가 1개인 인터페이스
	- 문법
		- 메서드
			- 리턴타입 메서드명(자료형 매개변수1, 자료형 매개변수2, ...){
				구현;
			  }
		- 람다식
			- (매개변수1,매개변수2)->{
				구현;
			  }
		- 간소화 된 람다식 : 매개변수가 1개 : ()생략가능, 실행문이 1줄 : {}와 ;생략
			- 매개변수1-> 실행문;
			
	- 함수형 인터페이스
		- Consumer : 매개변수O, 리턴X
		- Supplier : 매개변수X, 리턴O
		- Function : 매개변수O, 리턴O, 매개변수타입과 리턴타입이 다름
		- Operator : 매개변수O, 리턴O, 매개변수타입과 리턴타입이 같음
		- Predicate : 매개변수O, 리턴O, 리턴이 논리형(boolean)
	
	- 사용 예
		- List에서 sort로 정렬할 때
		- Thread를 생성할 때 Runable인터페이스를 이용하는 경우
		- Stream에서 메서드들을 이용할 때

스트림

	- 컬렉션이나 배열을 람다식으로 처리할 수 있게 해주는 반복자
	- 스트림 생성
		-배열
		int arr{} = ...;
		Stream stream = Arrays.stream(arr);
		- 리스트
		List<Integer> list = ...;
		Stream stream = list.stream();
	- filter
		- Predicate 인터페이스의 객체가 필요
		- 람다식으로 구현
		- 조건을 만족하는 요소들만 추출
	- map
		- Function 인터페이스의 객체가 필요
		- 람다식으로 구현
		- 스트림의 요소들을 다른 구조로 변환
	- forEach
		- Consumer 인터페이스의 객체가 필요
		- 람다식으로 구현
		- 스트림의 각 요소들이 실행할 코드를 구현
	- 집계 함수
		- count(),sum(),average()
	- 사용자 집계 함수
		- reduce()
		
자바입출력

	- 기반 스트림
		- 스트림 자체로 읽고/쓰기를 할 수 있는 스트림
	- 보조 스트림
		- 스트림 자체로 읽고/쓰기를 할 수 없어서 기반 스트림을 통해 읽기/쓰기를 함
		- 성능 향상을 위해
			- 가져온 데이터를 쉽게 문자열로,객체로
			- 여러 개를 한 번에 가져와서 속도를 향상
	- InputStream
		- 스트림을 통해 읽어올 때 사용 
	- OutputStream
		- 스트림을 통해 쓸 때 사용
		
쓰레드

	- 프로세스 내에서 실행하는 작업의 단위
	- 멀티 쓰레드
		- 여러 쓰레드를 생성해서 동시에 작업을 할 수 있게 함
	- 쓰레드 생성 방법
		- Thread 클래스 상속
			class MyThread extends Thread{
				// run()오버라이딩이 선택
			}
		- Runable 인터페이스의 구현 클래스를 이용하는 방법. 람다식 이용 가능
			class MyThread implements Runalble{
				
				// run()오버라이딩이 필수
				
				@Override
				public void run(){
				
				}
			}
			
	- 쓰레드 실행
		- thread.start();를 통해 실행
		- start()를 이용한 경우
			- 새 쓰레드를 생성
			- 새 쓰레드에 run()메서드를 실행
		- run()을 이용한 경우
			- 기존 쓰레드에 run()메서드를 실행
	- 동기화, 교착상태 주의
		- 동기화 : 어떤 작업을 동시에 진행하면 안될 때 한 쪽을 막아주는 것
		- 교착 상태 : 작업을 진행안하는데 하는 줄 알고 대기하는 상태

네트워크

	- 소켓 통신을 할 수 있다.
	- 서버 코드와 클라이언트 코드를 작성해서 통신을 할 수 있다
	
	
클래스 다이어그램

	+ : public
	- : private
	# : protected
	~ : default
	readOlny : final
	밑줄 : static
	private String mean;  => - mean : String
	final int test = 10; 	  => ~ test : int = 10(readOnly)
	static int count 	  => ~ count : int에 밑줄
	
	
파일 쓰기
	FileWriter wt = new FileWriter("파일명");	   	   	   : 기존 파일 덮어쓰기
	FileWriter wt = new FileWriter("파일명",true);	   : 기존 파일 이어쓰기

용어 정리

	- 상수 
		- 변수앞에 final이 붙어 있으면 상수
		- 이름이 있는 리터럴이라고 생각하면 편함
		
	- 리터럴
		- 1, 2, 'a', 3.14, "문자열"등과 같이 직접적인 값
